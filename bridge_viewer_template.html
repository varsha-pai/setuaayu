<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Bridge Digital Twin</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: monospace;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="info">Digital Twin Visualization<br>stress: <span id="stress-val">0</span> | vib: <span
            id="vib-val">0</span></div>

    <!-- Import Three.js from a CDN -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        // --- Data Injection Points (These will be replaced by Python) ---
        const VIB_X = Number('{{VIB_X}}');
        const VIB_Y = Number('{{VIB_Y}}');
        const VIB_Z = Number('{{VIB_Z}}');
        const STRESS = Number('{{STRESS}}');
        const TILT = Number('{{TILT}}');

        // Update UI Text
        document.getElementById('stress-val').innerText = STRESS;
        document.getElementById('vib-val').innerText = Math.max(VIB_X, VIB_Y, VIB_Z).toFixed(2);

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222); // Dark background

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(3, 3, 5);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- Bridge Geometry (Entire Span) ---
        // We will create a multi-span bridge with deck and pillars.

        // Materials
        let stressColor = 0x808080; // Gray
        if (STRESS > 300) { stressColor = 0xff0000; } // Critical
        else if (STRESS > 150) { stressColor = 0xffa500; } // Warning

        const concreteMaterial = new THREE.MeshPhongMaterial({ color: stressColor });
        const deckMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 }); // Darker road

        const pillars = [];
        const spans = 5;
        const spacing = 4;

        // Create Pillars & Deck
        for (let i = 0; i < spans; i++) {
            // Pillar
            const pGeo = new THREE.BoxGeometry(0.8, 4, 0.8);
            const pillar = new THREE.Mesh(pGeo, concreteMaterial);
            pillar.position.set((i * spacing) - ((spans * spacing) / 2) + 2, 0, 0); // Center the bridge
            pillar.castShadow = true;
            scene.add(pillar);
            pillars.push(pillar);

            // Deck Segment (connecting on top)
            const dGeo = new THREE.BoxGeometry(spacing + 0.2, 0.5, 2);
            const deck = new THREE.Mesh(dGeo, deckMaterial);
            deck.position.set(pillar.position.x, 2.25, 0); // Sit on top of pillar
            scene.add(deck);
        }

        // Adjust Camera to see whole bridge
        camera.position.set(0, 5, 12);
        camera.lookAt(0, 0, 0);

        // Grid helper
        const gridHelper = new THREE.GridHelper(40, 40);
        scene.add(gridHelper);

        let frame = 0;
        function animate() {
            requestAnimationFrame(animate);

            // Simulation of Vibration on ALL pillars (propagating wave effect)
            const jitterScale = 0.1;

            pillars.forEach((p, index) => {
                // Wave offset based on index
                const waveOffset = index * 0.5;

                p.position.y = (Math.sin(frame * 0.1 + waveOffset) * VIB_Y * 0.5)
                    + ((Math.random() - 0.5) * VIB_Y * jitterScale);

                // X/Z Jitter
                p.position.x = ((index * spacing) - ((spans * spacing) / 2) + 2) + ((Math.random() - 0.5) * VIB_X * jitterScale);
                p.position.z = (Math.random() - 0.5) * VIB_Z * jitterScale;

                // Tilt
                p.rotation.z = TILT * (Math.PI / 180) * 0.5; // Scaled down tilt for entire structure
            });

            controls.update();
            renderer.render(scene, camera);
            frame++;
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>